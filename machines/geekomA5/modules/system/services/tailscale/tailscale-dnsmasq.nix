{
  flake,
  config,
  pkgs,
  lib,
  ...
}:
let
  # This file is generated by Terraform in
  # LINK - terraform/tailscale/main.tf
  tailscaleMachineAddresses = (lib.importJSON "${flake}/managed-files/server_addresses.json").addresses;

  addresses = lib.concatMapStringsSep "\n" (addr: "address=/${config.custom.networking.domain}/${addr}") tailscaleMachineAddresses;

  dnsmasqConfig = pkgs.writeTextFile {
    name = "tailscale-dnsmasq.conf";
    text = ''
      # resolv-file=/run/systemd/resolve/resolv.conf
      # no-resolv # Don't read from /etc/resolv.conf
      bind-dynamic
      except-interface=lo
      interface=${config.services.tailscale.interfaceName}

      ${addresses}
    '';
  };

in
{
  systemd = {
    # services.dnsmasq is intended to be system-wide and it changes too many things in the config,
    # so it's easier to have this "local" server running with a limited scope
    services.tailscale-dnsmasq = {
      description = "Tailscale's Dnsmasq";
      after = [
        "network.target"
        config.systemd.services.systemd-resolved.name
        config.systemd.services.tailscaled.name
      ];
      bindsTo = [
        config.systemd.services.tailscaled.name
      ];
      wantedBy = [ "multi-user.target" ];

      serviceConfig = {
        ExecStart = "${lib.getExe pkgs.dnsmasq} --keep-in-foreground --conf-file=${dnsmasqConfig}";
        ExecReload = "${lib.getExe' pkgs.coreutils "kill"} -HUP $MAINPID";
        PrivateTmp = true;
        ProtectSystem = true;
        ProtectHome = true;
        Restart = "on-failure";
      };
    };
  };
}
